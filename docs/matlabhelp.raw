::

 FINUFFT1D1   1D complex nonuniform FFT of type 1 (nonuniform to uniform).

 [f ier] = finufft1d1(x,c,isign,eps,ms)
 [f ier] = finufft1d1(x,c,isign,eps,ms,opts)

 This computes, to relative precision eps, via a fast algorithm:

               nj
     f(k1) =  SUM c[j] exp(+/-i k1 x(j))  for -ms/2 <= k1 <= (ms-1)/2
              j=1
   Inputs:
     x     location of sources on interval [-3pi,3pi], length nj
     c     size-nj complex array of source strengths
     isign  if >=0, uses + sign in exponential, otherwise - sign.
     eps     precision requested (>1e-16)
     ms     number of Fourier modes computed, may be even or odd;
            in either case the mode range is integers lying in [-ms/2, (ms-1)/2]
     opts   optional struct with optional fields controlling the following:
     opts.debug: 0 (silent, default), 1 (timing breakdown), 2 (debug info).
     opts.spread_sort: 0 (don't sort NU pts), 1 (do), 2 (auto, default)
     opts.fftw: FFTW plan mode, 64=FFTW_ESTIMATE (default), 0=FFTW_MEASURE, etc
     opts.upsampfac: either 2.0 (default), or 1.25 (low RAM, smaller FFT size)
     opts.modeord: 0 (CMCL increasing mode ordering, default), 1 (FFT ordering)
     opts.chkbnds: 0 (don't check NU points valid), 1 (do, default)
   Outputs:
     f     size-ms double complex array of Fourier transform values
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io

::

 FINUFFT1D2   1D complex nonuniform FFT of type 2 (uniform to nonuniform).

 [c ier] = finufft1d2(x,isign,eps,f)
 [c ier] = finufft1d2(x,isign,eps,f,opts)

 This computes, to relative precision eps, via a fast algorithm:

    c[j] = SUM   f[k1] exp(+/-i k1 x[j])      for j = 1,...,nj
            k1
     where sum is over -ms/2 <= k1 <= (ms-1)/2.

  Inputs:
     x     location of NU targets on interval [-3pi,3pi], length nj
     f     complex Fourier transform values
     isign  if >=0, uses + sign in exponential, otherwise - sign.
     eps    precision requested (>1e-16)
     opts   optional struct with optional fields controlling the following:
     opts.debug: 0 (silent, default), 1 (timing breakdown), 2 (debug info).
     opts.spread_sort: 0 (don't sort NU pts), 1 (do), 2 (auto, default)
     opts.fftw: FFTW plan mode, 64=FFTW_ESTIMATE (default), 0=FFTW_MEASURE, etc
     opts.upsampfac: either 2.0 (default), or 1.25 (low RAM, smaller FFT size)
     opts.modeord: 0 (CMCL increasing mode ordering, default), 1 (FFT ordering)
     opts.chkbnds: 0 (don't check NU points valid), 1 (do, default)
  Outputs:
     c     complex double array of nj answers at targets
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io

::

 FINUFFT1D3   1D complex nonuniform FFT of type 3 (nonuniform to nonuniform).

 [f ier] = finufft1d3(x,c,isign,eps,s)
 [f ier] = finufft1d3(x,c,isign,eps,s,opts)

 This computes:

              nj
     f[k]  =  SUM   c[j] exp(+-i s[k] x[j]),      for k = 1, ..., nk
              j=1
   Inputs:
     x      location of NU sources in R (real line).
     c      size-nj double complex array of source strengths
     s      frequency locations of NU targets in R.
     isign  if >=0, uses + sign in exponential, otherwise - sign.
     eps    precision requested (>1e-16)
     opts   optional struct with optional fields controlling the following:
     opts.debug: 0 (silent, default), 1 (timing breakdown), 2 (debug info).
     opts.spread_sort: 0 (don't sort NU pts), 1 (do), 2 (auto, default)
     opts.fftw: FFTW plan mode, 64=FFTW_ESTIMATE (default), 0=FFTW_MEASURE, etc
     opts.upsampfac: either 2.0 (default), or 1.25 (low RAM, smaller FFT size)
   Outputs:
     f     size-nk double complex Fourier transform values at target
            frequencies s
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io

::

 FINUFFT2D1   2D complex nonuniform FFT of type 1 (nonuniform to uniform).

 [f ier] = finufft2d1(x,y,c,isign,eps,ms,mt)
 [f ier] = finufft2d1(x,y,c,isign,eps,ms,mt,opts)

 This computes, to relative precision eps, via a fast algorithm:

                   nj
     f[k1,k2] =   SUM  c[j] exp(+-i (k1 x[j] + k2 y[j]))
                  j=1

     for -ms/2 <= k1 <= (ms-1)/2,  -mt/2 <= k2 <= (mt-1)/2.

   Inputs:
     x,y   locations of NU sources on the square [-3pi,3pi]^2, each length nj
     c     size-nj complex array of source strengths
     isign  if >=0, uses + sign in exponential, otherwise - sign.
     eps     precision requested (>1e-16)
     ms,mt  number of Fourier modes requested in x & y; each may be even or odd
           in either case the mode range is integers lying in [-m/2, (m-1)/2]
     opts   optional struct with optional fields controlling the following:
     opts.debug: 0 (silent, default), 1 (timing breakdown), 2 (debug info).
     opts.spread_sort: 0 (don't sort NU pts), 1 (do), 2 (auto, default)
     opts.fftw: FFTW plan mode, 64=FFTW_ESTIMATE (default), 0=FFTW_MEASURE, etc
     opts.upsampfac: either 2.0 (default), or 1.25 (low RAM, smaller FFT size)
     opts.modeord: 0 (CMCL increasing mode ordering, default), 1 (FFT ordering)
     opts.chkbnds: 0 (don't check NU points valid), 1 (do, default)
   Outputs:
     f     size (ms*mt) double complex array of Fourier transform values
           (ordering given by opts.modeord in each dimension, ms fast, mt slow)
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io

::

 FINUFFT2D2   2D complex nonuniform FFT of type 2 (uniform to nonuniform).

 [c ier] = finufft2d2(x,y,isign,eps,f)
 [c ier] = finufft2d2(x,y,isign,eps,f,opts)

 This computes, to relative precision eps, via a fast algorithm:

    c[j] =  SUM   f[k1,k2] exp(+/-i (k1 x[j] + k2 y[j]))  for j = 1,..,nj
           k1,k2
     where sum is over -ms/2 <= k1 <= (ms-1)/2, -mt/2 <= k2 <= (mt-1)/2,

  Inputs:
     x,y   location of NU targets on the square [-3pi,3pi]^2, each length nj
     f     size (ms,mt) complex Fourier transform value matrix
           (mode ordering given by opts.modeord in each dimension)
     isign  if >=0, uses + sign in exponential, otherwise - sign.
     eps    precision requested (>1e-16)
     opts   optional struct with optional fields controlling the following:
     opts.debug: 0 (silent, default), 1 (timing breakdown), 2 (debug info).
     opts.spread_sort: 0 (don't sort NU pts), 1 (do), 2 (auto, default)
     opts.fftw: FFTW plan mode, 64=FFTW_ESTIMATE (default), 0=FFTW_MEASURE, etc
     opts.upsampfac: either 2.0 (default), or 1.25 (low RAM, smaller FFT size)
     opts.modeord: 0 (CMCL increasing mode ordering, default), 1 (FFT ordering)
     opts.chkbnds: 0 (don't check NU points valid), 1 (do, default)
  Outputs:
     c     complex double array of nj answers at the targets.
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io

::

 FINUFFT2D3   2D complex nonuniform FFT of type 3 (nonuniform to nonuniform).

 [f ier] = finufft2d3(x,y,c,isign,eps,s,t)
 [f ier] = finufft2d3(x,y,c,isign,eps,s,t,opts)

 This computes, to relative precision eps, via a fast algorithm:

              nj
     f[k]  =  SUM   c[j] exp(+-i (s[k] x[j] + t[k] y[j])),  for k = 1, ..., nk
              j=1
   Inputs:
     x,y    location of NU sources in R^2, each length nj.
     c      size-nj double complex array of source strengths
     s,t    frequency locations of NU targets in R^2.
     isign  if >=0, uses + sign in exponential, otherwise - sign.
     eps    precision requested (>1e-16)
     opts   optional struct with optional fields controlling the following:
     opts.debug: 0 (silent, default), 1 (timing breakdown), 2 (debug info).
     opts.spread_sort: 0 (don't sort NU pts), 1 (do), 2 (auto, default)
     opts.fftw: FFTW plan mode, 64=FFTW_ESTIMATE (default), 0=FFTW_MEASURE, etc
     opts.upsampfac: either 2.0 (default), or 1.25 (low RAM, smaller FFT size)
   Outputs:
     f     size-nk double complex Fourier transform values at target
            frequencies s,t
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io

::

 FINUFFT3D1   3D complex nonuniform FFT of type 1 (nonuniform to uniform).

 [f ier] = finufft3d1(x,y,z,c,isign,eps,ms,mt,mu)
 [f ier] = finufft3d1(x,y,z,c,isign,eps,ms,mt,mu,opts)

 This computes, to relative precision eps, via a fast algorithm:

                       nj
     f[k1,k2,k3] =    SUM  c[j] exp(+-i (k1 x[j] + k2 y[j] + k3 z[j]))
                      j=1

     for -ms/2 <= k1 <= (ms-1)/2,  -mt/2 <= k2 <= (mt-1)/2,
         -mu/2 <= k3 <= (mu-1)/2.

   Inputs:
     x,y,z locations of NU sources on [-3pi,3pi]^3, each length nj
     c     size-nj complex array of source strengths
     isign  if >=0, uses + sign in exponential, otherwise - sign.
     eps     precision requested (>1e-16)
     ms,mt,mu number of Fourier modes requested in x,y and z; each may be
           even or odd.
           In either case the mode range is integers lying in [-m/2, (m-1)/2]
     opts   optional struct with optional fields controlling the following:
     opts.debug: 0 (silent, default), 1 (timing breakdown), 2 (debug info).
     opts.spread_sort: 0 (don't sort NU pts), 1 (do), 2 (auto, default)
     opts.fftw: FFTW plan mode, 64=FFTW_ESTIMATE (default), 0=FFTW_MEASURE, etc
     opts.upsampfac: either 2.0 (default), or 1.25 (low RAM, smaller FFT size)
     opts.modeord: 0 (CMCL increasing mode ordering, default), 1 (FFT ordering)
     opts.chkbnds: 0 (don't check NU points valid), 1 (do, default)
   Outputs:
     f     size (ms*mt*mu) double complex array of Fourier transform values
            (ordering given by opts.modeord in each dimension, ms fastest, mu
             slowest).
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io

::

 FINUFFT3D2   3D complex nonuniform FFT of type 2 (uniform to nonuniform).

 [c ier] = finufft3d2(x,y,z,isign,eps,f)
 [c ier] = finufft3d2(x,y,z,isign,eps,f,opts)

 This computes, to relative precision eps, via a fast algorithm:

    c[j] =   SUM   f[k1,k2,k3] exp(+/-i (k1 x[j] + k2 y[j] + k3 z[j]))
           k1,k2,k3
                            for j = 1,..,nj
     where sum is over -ms/2 <= k1 <= (ms-1)/2, -mt/2 <= k2 <= (mt-1)/2,
                       -mu/2 <= k3 <= (mu-1)/2.

  Inputs:
     x,y,z location of NU targets on cube [-3pi,3pi]^3, each length nj
     f     size (ms,mt,mu) complex Fourier transform value matrix
           (ordering given by opts.modeord in each dimension; ms fastest to mu
            slowest).
     isign  if >=0, uses + sign in exponential, otherwise - sign.
     eps    precision requested (>1e-16)
     opts   optional struct with optional fields controlling the following:
     opts.debug: 0 (silent, default), 1 (timing breakdown), 2 (debug info).
     opts.spread_sort: 0 (don't sort NU pts), 1 (do), 2 (auto, default)
     opts.fftw: FFTW plan mode, 64=FFTW_ESTIMATE (default), 0=FFTW_MEASURE, etc
     opts.upsampfac: either 2.0 (default), or 1.25 (low RAM, smaller FFT size)
     opts.modeord: 0 (CMCL increasing mode ordering, default), 1 (FFT ordering)
     opts.chkbnds: 0 (don't check NU points valid), 1 (do, default)
  Outputs:
     c     complex double array of nj answers at the targets.
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io

::

 FINUFFT3D3   3D complex nonuniform FFT of type 3 (nonuniform to nonuniform).

 [f ier] = finufft3d3(x,y,z,c,isign,eps,s,t,u)
 [f ier] = finufft3d3(x,y,z,c,isign,eps,s,t,u,opts)

 This computes, to relative precision eps, via a fast algorithm:

              nj
     f[k]  =  SUM   c[j] exp(+-i (s[k] x[j] + t[k] y[j] + u[k] z[j])),
              j=1
                              for k = 1, ..., nk
   Inputs:
     x,y,z  location of NU sources in R^3, each length nj.
     c      size-nj double complex array of source strengths
     s,t,u   frequency locations of NU targets in R^3.
     isign  if >=0, uses + sign in exponential, otherwise - sign.
     eps    precision requested (>1e-16)
     opts   optional struct with optional fields controlling the following:
     opts.debug: 0 (silent, default), 1 (timing breakdown), 2 (debug info).
     opts.spread_sort: 0 (don't sort NU pts), 1 (do), 2 (auto, default)
     opts.fftw: FFTW plan mode, 64=FFTW_ESTIMATE (default), 0=FFTW_MEASURE, etc
     opts.upsampfac: either 2.0 (default), or 1.25 (low RAM, smaller FFT size)
   Outputs:
     f     size-nk double complex Fourier transform values at target
            frequencies s,t,u
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io

::

 this is a dummy property to tell MWrap to treat this in OO way...
 (mwptr = MWrap-pointer, not MathWorks!)
 FINUFFT_PLAN   create guru plan object for one/many general nonuniform FFTs.

 [plan] = finufft_plan(type, n_modes_or_dim, iflag, ntrans, eps)
 [plan] = finufft_plan(type, n_modes_or_dim, iflag, ntrans, eps, opts)

 Creates a finufft_plan MATLAB object in the guru interface to FINUFFT, of
  type 1,2 or 3.

 Inputs: 
     type            transform type, 1, 2, or 3
     n_modes_or_dim  if type is 1 or 2, the number of Fourier modes in each
                     dimension: [ms] in 1D, [ms mt] in 2D, or [ms mt mu] in 3D.
                     Its length sets the dimension, which must be 1, 2 or 3.
                     If type is 3, in constrast, its value sets the dimension.
     iflag           if >=0, uses + sign in exponential, otherwise - sign
     eps             precision requested (>1e-16)
     opts   optional struct with optional fields controlling the following:
     opts.debug: 0 (silent, default), 1 (timing breakdown), 2 (debug info).
     opts.spread_sort: 0 (don't sort NU pts), 1 (do), 2 (auto, default)
     opts.fftw: FFTW plan mode, 64=FFTW_ESTIMATE (default), 0=FFTW_MEASURE, etc
     opts.upsampfac: either 2.0 (default), or 1.25 (low RAM, smaller FFT size)
     for type 1 and 2 only, the following opts fields are active:
     opts.modeord: 0 (CMCL increasing mode ordering, default), 1 (FFT ordering)
     opts.chkbnds: 0 (don't check NU points valid), 1 (do, default)
 Outputs:
     plan            finufft_plan object
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io
 NODOCS
 FINUFFT_DESTROY   deallocate (delete) a nonuniform FFT plan

 finufft_destroy(plan) deallocates and forgets a FINUFFT plan object.

 See also: FINUFFT_PLAN
 FINUFFT_SETPTS    Process nonuniform points for general NUFFT transform(s).

 to do
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io
 FINUFFT_EXEC    execute single or many-vector NUFFT transforms in a plan

 to do
     ier   0 if success, else:
           1 : eps too small (transform still performed at closest eps)
           2 : size of arrays to malloc exceed MAX_NF
           3 : spreader: fine grid too small compared to spread (kernel) width
           4 : spreader: if chkbnds=1, nonuniform pt out of range [-3pi,3pi]^d
           5 : spreader: array allocation error
           6 : spreader: illegal direction (should be 1 or 2)
           7 : upsampfac too small (should be >1.0)
           8 : upsampfac not a value with known Horner poly eval rule
           9 : ntrans invalid in "many" (vectorized) or guru interface
          10 : transform type invalid (guru)
          11 : general allocation failure
          12 : dimension invalid (guru)

 Notes:
  * All available threads are used; control how many with maxNumCompThreads.
  * The above documents the simple (single-transform) interface. To transform
    ntrans vectors together with the same nonuniform points, add a final
    dimension of size ntrans>1 to the f and c arrays. See ../docs/matlab.rst
  * For more details about the opts fields, see ../docs/opts.rst
  * Full documentation is given in ../finufft-manual.pdf and online at
    http://finufft.readthedocs.io

