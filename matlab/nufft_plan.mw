% nufft_plan.mw
%   FINUFFT plan wrapper

$ #include <finufft.h>
$ #include <mex.h>
$ #include <iostream>
$ #include <cstring>
$ #include <math.h>

$ void copy_nufft_opts(const mxArray* om, nufft_opts *oc) {
$   if(!mxIsStruct(om))
$     mexErrMsgIdAndTxt("MATLAB:copy_nufft_opts:inputNotStruct","Input must be a structure.");
$   mwIndex idx = 0;
$   int ifield, nfields;
$   const char **fname;
$   nfields = mxGetNumberOfFields(om);
$   fname = (const char**)mxCalloc(nfields, sizeof(*fname));
$   for(ifield=0; ifield<nfields; ifield++) {
$     fname[ifield] = mxGetFieldNameByNumber(om,ifield);
$     if (strcmp(fname[ifield],"debug") == 0) {
$       oc->debug = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_debug") == 0) {
$       oc->spread_debug = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_sort") == 0) {
$       oc->spread_sort = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_kerevalmeth") == 0) {
$       oc->spread_kerevalmeth = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_kerpad") == 0) {
$       oc->spread_kerpad = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"chkbnds") == 0) {
$       oc->chkbnds = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"fftw") == 0) {
$       int fftw = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$       oc->fftw = !fftw ? FFTW_ESTIMATE : FFTW_MEASURE;  
$     }
$     else if (strcmp(fname[ifield],"modeord") == 0) {
$       oc->modeord = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"upsampfac") == 0) {
$       oc->upsampfac = (FLT)*mxGetPr(mxGetFieldByNumber(om,idx,ifield));
$     }
$     else if (strcmp(fname[ifield],"spread_scheme") == 0) {
$       oc->spread_scheme = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else
$       return;
$   }
$   mxFree(fname);
$ }


@ nufft_plan.m --------------------------------------------

classdef nufft_plan < handle

  properties
    mwptr;
    nthreads_user;
    nthreads_omp;
  end

  methods

    function [plan] = nufft_plan(type, n_modes, iflag, n_transf, tol, blksize, opts)
      # finufft_plan* p = new finufft_plan();
      plan.mwptr = p;
      assert(type==1 || type==2 || type==3);
      if type==3
        assert(length(n_modes)==1);
        n_dims = n_modes;
      else
        n_dims = length(n_modes);
      end
      assert(n_dims==1 || n_dims==2 || n_dims==3);
      % if n_modes had length <3, pad with 1's (also overwrites whatever there):
      if n_dims<2, n_modes(2)=1; end
      if n_dims<3, n_modes(3)=1; end
      if nargin<7
        # nufft_opts* o = new nufft_opts();
        # finufft_default_opts(nufft_opts* o);
        # int ier = finufft_makeplan(int type, int n_dims, int64_t[3] n_modes, int iflag, int n_transf, double tol, int blksize, finufft_plan* plan, nufft_opts* o);
        # delete(nufft_opts* o);
      else
        % first set o with default value and then replace with fields in opts
        # nufft_opts* o = new nufft_opts();
        # finufft_default_opts(nufft_opts* o);
        # copy_nufft_opts(mxArray opts, nufft_opts* o);
        # int ier = finufft_makeplan(int type, int n_dims, int64_t[3] n_modes, int iflag, int n_transf, double tol, int blksize, finufft_plan* plan, nufft_opts* o);
        # delete(nufft_opts* o);
      end
    end

    function delete(plan)
      # finufft_destroy(finufft_plan* plan);
    end

    function nufft_destroy(plan)
      # finufft_destroy(finufft_plan* plan);
    end

    function [ier] = nufft_setpts(plan, xj, yj, zj, s, t, u)
      nj = numel(xj);   % note the matlab way is to extract sizes like this
      nk = numel(s);
      # int ier = finufft_setpts(finufft_plan* plan, int64_t nj, double[] xj, double[] yj, double[] zj, int64_t nk, double[] s, double[] t, double[] u);
    end

    function [result, ier] = nufft_excute(plan, data_in)
      $ int get_type(finufft_plan* plan) {
      $   return plan->type;
      $ }
      $ int get_ndim(finufft_plan* plan) {
      $   return plan->n_dims;
      $ }
      $ int64_t get_nj(finufft_plan* plan) {
      $   return plan->nj;
      $ }
      $ int64_t get_nk(finufft_plan* plan) {
      $   return plan->nk;
      $ }
      $ void get_nmodes(finufft_plan* plan, int64_t& ms, int64_t& mt, int64_t& mu) {
      $   ms = plan->ms ? plan->ms : 1;
      $   mt = plan->mt ? plan->mt : 1;
      $   mu = plan->mu ? plan->mu : 1;
      $   if(plan->n_dims<3) mu=1;
      $   if(plan->n_dims<2) mt=1;
      $ }
      $ int get_ntransf(finufft_plan* plan) {
      $   return plan->n_transf;
      $ }

      # int type = get_type(finufft_plan* plan);
      # int n_transf = get_ntransf(finufft_plan* plan);

      if type==1
        # get_nmodes(finufft_plan* plan, output int64_t& ms, output int64_t& mt, output int64_t& mu);
        outsize = ms*mt*mu*n_transf;
        # int ier = finufft_exec(finufft_plan* plan, dcomplex[] data_in, output dcomplex[outsize] result);
        reshape(result, ms, mt, mu, n_transf);
      elseif type==2
        # int64_t nj = get_nj(finufft_plan* plan);
        # int ier = finufft_exec(finufft_plan* plan, output dcomplex[nj, n_transf] result, dcomplex[] data_in);
      elseif type==3
        # int64_t nk = get_nk(finufft_plan* plan);
        # int ier = finufft_exec(finufft_plan* plan, dcomplex[] data_in, output dcomplex[nk, n_transf] result);
      else
        result = 4;
        ier = 1;
      end
    end

  end
end
