% finufft.mw
% MWrap MEX interface descriptor file for FINUFFT, using the new guru interface.
% This provides an object-oriented style interface to the guru interface, by
% mirroring the finufft_plan C++ object with a matlab object "finufft_plan".
% The OO use makes it compatible only with MATLAB R2008a or later, and octave
% version 4.4 or later.
%
% To match the object name, generated matlab interface is (and must be) called
% finufft_plan.m; see Path Folders here:
% https://www.mathworks.com/help/matlab/matlab_oop/organizing-classes-in-folders.html
%
% Hints for linux/GNU build (see ../makefile for definitive build):
% To generate the MEX C++ file, run these both:
%
% mwrap -list -mex finufft -cppcomplex -mb finufft.mw
% mwrap -mex finufft -c finufft.cpp -cppcomplex finufft.mw
%
% Then to compile for matlab:
% mex finufft.cpp ../lib/libfinufft.a -largeArrayDims -DR2008OO -D_INT64_T -lfftw3_omp -lfftw3 -lgomp -lm
% And to compile for octave:
% mkoctfile --mex finufft.cpp ../lib/libfinufft.a -DR2008OO -D_INT64_T -lfftw3_omp -lfftw3 -lgomp -lm
% Don't forget to add this directory to your matlab/octave path.
%
% See also: finufft?d?.m in this directory for the simple/many interfaces which
% call finufft_plan.m, or test/guru1dtest.m for direct example.
%
% Notes:
%  0) see mwrap documentation for how this type of .mw file works:
%     https://github.com/zgimbutas/mwrap
%  1) Double-precision only for now.
%  2) in the FINUFFT library, BIGINT type must be int64_t, as is default.
%     Since int64_t is hardwired in the below, MEX will break otherwise.
%  3) only compatible with FINUFFT version>=1.2; supercedes old simple/many
%     interfaces.
%  4) The 1-line help strings after each function must be left for doc gen
%     (see README).
%
% Main author: Libin Lu, started May 2020; edits & docs by Alex Barnett.

$ #include <finufft.h>
$ #include <mex.h>
$ #include <iostream>
$ #include <cstring>
$ #include <math.h>


% .........................................................................
% This C++ code overwrites any properties of nufft_opts *oc with any valid
% fields in the matlab struct *om.
%
$ void copy_nufft_opts(const mxArray* om, nufft_opts *oc) {
$   if(!mxIsStruct(om))
$     mexErrMsgIdAndTxt("MATLAB:copy_nufft_opts:inputNotStruct","Input must be a structure.");
$   mwIndex idx = 0;
$   int ifield, nfields;
$   const char **fname;
$   nfields = mxGetNumberOfFields(om);
$   fname = (const char**)mxCalloc(nfields, sizeof(*fname));
$   for(ifield=0; ifield<nfields; ifield++) {
$     fname[ifield] = mxGetFieldNameByNumber(om,ifield);
$     if (strcmp(fname[ifield],"debug") == 0) {
$       oc->debug = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_debug") == 0) {
$       oc->spread_debug = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_sort") == 0) {
$       oc->spread_sort = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_kerevalmeth") == 0) {
$       oc->spread_kerevalmeth = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_kerpad") == 0) {
$       oc->spread_kerpad = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"chkbnds") == 0) {
$       oc->chkbnds = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"fftw") == 0) {
$       oc->fftw = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"modeord") == 0) {
$       oc->modeord = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"upsampfac") == 0) {
$       oc->upsampfac = (FLT)*mxGetPr(mxGetFieldByNumber(om,idx,ifield));
$     }
$     else if (strcmp(fname[ifield],"spread_thread") == 0) {
$       oc->spread_thread = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"maxbatchsize") == 0) {
$       oc->maxbatchsize = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"nthreads") == 0)
$       mexWarnMsgIdAndTxt("MATLAB:copy_nufft_opts:nthreadsObsolete","FINUFFT opts.nthreads is obsolete, does nothing; please use maxNumCompThreads.");
$     else
$       continue;
$   }
$   mxFree(fname);
$ }

$ void finufft_mex_setup() {
$   /* Forces MATLAB to properly initialize their FFTW library. */
$   mexEvalString("fft(1:8);");
$ }


@ finufft_plan.m --------------------------------------------

classdef finufft_plan < handle

  properties
% this is a dummy property to tell MWrap to treat this in OO way...
% (mwptr = MWrap-pointer, not MathWorks!)
    mwptr;
  end

  methods

    function [plan, ier] = finufft_plan(type, n_modes_or_dim, iflag, n_transf, tol, opts)
    % FINUFFT_PLAN
      # finufft_mex_setup();
      # finufft_plan* p = new finufft_plan();
      plan.mwptr = p;                        % alex asks: is this needed? 
      assert(type==1 || type==2 || type==3);
      n_modes = ones(3,1);    % dummy for type 3
      if type==3
        assert(length(n_modes_or_dim)==1);
        dim = n_modes_or_dim;      % interpret as dim
      else
        dim = length(n_modes_or_dim);
        n_modes(1:dim) = n_modes_or_dim;
      end
      assert(dim==1 || dim==2 || dim==3);
      if nargin<6
        # nufft_opts* o = new nufft_opts();
        # finufft_default_opts(nufft_opts* o);
        # int ier = finufft_makeplan(int type, int dim, int64_t[3] n_modes, int iflag, int n_transf, double tol, finufft_plan* plan, nufft_opts* o);
        # delete(nufft_opts* o);
      else
        % first set o with default value and then replace with fields in opts
        # nufft_opts* o = new nufft_opts();
        # finufft_default_opts(nufft_opts* o);
        # copy_nufft_opts(mxArray opts, nufft_opts* o);
        # int ier = finufft_makeplan(int type, int dim, int64_t[3] n_modes, int iflag, int n_transf, double tol, finufft_plan* plan, nufft_opts* o);
        # delete(nufft_opts* o);
      end
    end

    function delete(plan)
    % NODOCS
      # finufft_destroy(finufft_plan* plan);
    end

    function finufft_destroy(plan)
    % FINUFFT_DESTROY
      # finufft_destroy(finufft_plan* plan);
    end

    function [ier] = finufft_setpts(plan, xj, yj, zj, s, t, u)
    % FINUFFT_SETPTS
      nj = numel(xj);   % note the matlab way is to extract sizes like this
      nk = numel(s);
      # int ier = finufft_setpts(finufft_plan* plan, int64_t nj, double[] xj, double[] yj, double[] zj, int64_t nk, double[] s, double[] t, double[] u);
    end

    function [result, ier] = finufft_exec(plan, data_in)
    % FINUFFT_EXEC
      $ int get_type(finufft_plan* plan) {
      $   return plan->type;
      $ }
      $ int get_ndim(finufft_plan* plan) {
      $   return plan->dim;
      $ }
      $ int64_t get_nj(finufft_plan* plan) {
      $   return plan->nj;
      $ }
      $ int64_t get_nk(finufft_plan* plan) {
      $   return plan->nk;
      $ }
      $ void get_nmodes(finufft_plan* plan, int64_t& ms, int64_t& mt, int64_t& mu) {
      $   ms = plan->ms ? plan->ms : 1;
      $   mt = plan->mt ? plan->mt : 1;
      $   mu = plan->mu ? plan->mu : 1;
      $   if(plan->dim<3) mu=1;
      $   if(plan->dim<2) mt=1;
      $ }
      $ int get_ntransf(finufft_plan* plan) {
      $   return plan->ntrans;
      $ }

      # int type = get_type(finufft_plan* plan);
      # int n_transf = get_ntransf(finufft_plan* plan);

      if type==1
        # get_nmodes(finufft_plan* plan, output int64_t& ms, output int64_t& mt, output int64_t& mu);
        outsize = ms*mt*mu*n_transf;
        # int ier = finufft_exec(finufft_plan* plan, dcomplex[] data_in, output dcomplex[outsize] result);
        result = reshape(result, [ms mt mu n_transf]);
      elseif type==2
        # int64_t nj = get_nj(finufft_plan* plan);
        # int ier = finufft_exec(finufft_plan* plan, output dcomplex[nj, n_transf] result, dcomplex[] data_in);
      elseif type==3
        # int64_t nk = get_nk(finufft_plan* plan);
        # int ier = finufft_exec(finufft_plan* plan, dcomplex[] data_in, output dcomplex[nk, n_transf] result);
      else
        result = [];       % why was it 4?
        ier = 1;
      end
    end

  end
end
