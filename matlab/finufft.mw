% finufft.mw
% MWrap MEX interface descriptor file for FINUFFT, using the new guru interface.
% This provides an object-oriented style interface to the guru interface, by
% mirroring the finufft_plan C++ object with a matlab object "finufft_plan".
% The OO use makes it compatible only with MATLAB R2008a or later, and octave
% version 4.4 or later.
%
% To match the object name, generated matlab interface is (and must be) called
% finufft_plan.m; see Path Folders here:
% https://www.mathworks.com/help/matlab/matlab_oop/organizing-classes-in-folders.html
%
% Hints for linux/GNU build (see ../makefile for definitive build):
% To generate the MEX C++ file, run these both:
%
% mwrap -list -mex finufft -cppcomplex -mb finufft.mw
% mwrap -mex finufft -c finufft.cpp -cppcomplex finufft.mw
%
% Then to compile for matlab:
% mex finufft.cpp ../lib/libfinufft.a -largeArrayDims -DR2008OO -D_INT64_T -lfftw3_omp -lfftw3 -lgomp -lm
% And to compile for octave:
% mkoctfile --mex finufft.cpp ../lib/libfinufft.a -DR2008OO -D_INT64_T -lfftw3_omp -lfftw3 -lgomp -lm
% Don't forget to add this directory to your matlab/octave path.
%
% See also: finufft?d?.m in this directory for the simple/many interfaces which
% call finufft_plan.m, or test/guru1dtest.m for direct example.
%
% Notes:
%  0) see mwrap's documentation for how this type of .mw file works:
%     https://github.com/zgimbutas/mwrap
%  1) Double-precision only for now.
%  2) in the FINUFFT library, BIGINT type must be int64_t, as is default.
%     Since int64_t is hardwired in the below, MEX will break otherwise.
%  3) only compatible with FINUFFT version>=1.2; supercedes old simple/many
%     interfaces.
%  4) detailed user documentation is prepended to finufft_plan.m by addmhelp.sh
%
% Main author: Libin Lu, started May 2020; edits, ier, docs by Alex Barnett.

$ #include <finufft.h>
$ #include <mex.h>
$ #include <iostream>
$ #include <cstring>
$ #include <math.h>


% .........................................................................
% This C++ code overwrites any properties of nufft_opts *oc with any valid
% fields in the matlab struct *om.
%
$ void copy_nufft_opts(const mxArray* om, nufft_opts *oc) {
$   if(!mxIsStruct(om))
$     mexErrMsgIdAndTxt("FINUFFT:inputNotStruct","opts input must be a structure.");
$   mwIndex idx = 0;
$   int ifield, nfields;
$   const char **fname;
$   nfields = mxGetNumberOfFields(om);
$   fname = (const char**)mxCalloc(nfields, sizeof(*fname));
$   for(ifield=0; ifield<nfields; ifield++) {
$     fname[ifield] = mxGetFieldNameByNumber(om,ifield);
$     if (strcmp(fname[ifield],"debug") == 0) {
$       oc->debug = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_debug") == 0) {
$       oc->spread_debug = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_sort") == 0) {
$       oc->spread_sort = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_kerevalmeth") == 0) {
$       oc->spread_kerevalmeth = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"spread_kerpad") == 0) {
$       oc->spread_kerpad = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"chkbnds") == 0) {
$       oc->chkbnds = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"fftw") == 0) {
$       oc->fftw = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"modeord") == 0) {
$       oc->modeord = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"upsampfac") == 0) {
$       oc->upsampfac = (FLT)*mxGetPr(mxGetFieldByNumber(om,idx,ifield));
$     }
$     else if (strcmp(fname[ifield],"spread_thread") == 0) {
$       oc->spread_thread = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"maxbatchsize") == 0) {
$       oc->maxbatchsize = (int)round(*mxGetPr(mxGetFieldByNumber(om,idx,ifield)));
$     }
$     else if (strcmp(fname[ifield],"nthreads") == 0)
$       mexWarnMsgIdAndTxt("FINUFFT:nthreadsObsolete","FINUFFT opts.nthreads is obsolete, does nothing; please use maxNumCompThreads.");
$     else
$       continue;
$   }
$   mxFree(fname);
$ }

$ void finufft_mex_setup() {
$   /* Forces MATLAB to properly initialize their FFTW library. */
$   mexEvalString("fft(1:8);");
$ }


@ finufft_plan.m --------------------------------------------

classdef finufft_plan < handle

  properties
% this is a special property that MWrap uses as an opaque pointer to C++ object
% (mwptr = MWrap-pointer, not MathWorks!)
    mwptr
  end

  methods

    function plan = finufft_plan(type, n_modes_or_dim, iflag, n_transf, tol, opts)
    % FINUFFT_PLAN   create guru plan object for one/many general nonuniform FFTs.

      # finufft_mex_setup();
      # finufft_plan* p = new finufft_plan();
      plan.mwptr = p;       % crucial: save the opaque ptr as in p.12 of MWrap manual
      
      n_modes = ones(3,1);  % dummy for type 3
      if type==3
        if length(n_modes_or_dim)~=1
          error('FINUFFT:badT3dim', 'FINUFFT type 3 plan n_modes_or_dim must be one number, the dimension');
        end
        dim = n_modes_or_dim;      % interpret as dim
      else
        dim = length(n_modes_or_dim);
        n_modes(1:dim) = n_modes_or_dim;
      end
      % (checks of type and dim will occur in the C++ library so omit them above)

      # nufft_opts* o = new nufft_opts();
      # finufft_default_opts(nufft_opts* o);
      if nargin==6                 % replace whichever fields are in opts
        # copy_nufft_opts(mxArray opts, nufft_opts* o);
      end
      # int ier = finufft_makeplan(int type, int dim, int64_t[3] n_modes, int iflag, int n_transf, double tol, finufft_plan* plan, nufft_opts* o);
      # delete(nufft_opts* o);
      errhandler(ier);             % convert C++ codes to matlab-style errors
    end

    function delete(plan)
      # finufft_destroy(finufft_plan* plan);
    end

    function finufft_destroy(plan)
    % FINUFFT_DESTROY   deallocate (delete) a nonuniform FFT plan.
      # finufft_destroy(finufft_plan* plan);
    end

    function finufft_setpts(plan, xj, yj, zj, s, t, u)
    % FINUFFT_SETPTS   process nonuniform points for general NUFFT transform(s).
      if nargin<5, s=[]; t=[]; u=[]; end
      
      $ int get_type(finufft_plan* plan) {
      $   return plan->type;
      $ }
      $ int get_dim(finufft_plan* plan) {
      $   return plan->dim;
      $ }
      
      # int dim = get_dim(finufft_plan* plan);
      # int type = get_type(finufft_plan* plan);
      % get number(s) of NU pts (also validates the NU pt array sizes)...
      [nj, nk] = valid_setpts(type, dim, xj, yj, zj, s, t, u);
      # int ier = finufft_setpts(finufft_plan* plan, int64_t nj, double[] xj, double[] yj, double[] zj, int64_t nk, double[] s, double[] t, double[] u);
      errhandler(ier);
    end

    function result = finufft_exec(plan, data_in)
    % FINUFFT_EXEC   execute single or many-vector NUFFT transforms in a plan.

      $ int64_t get_nj(finufft_plan* plan) {
      $   return plan->nj;
      $ }
      $ int64_t get_nk(finufft_plan* plan) {
      $   return plan->nk;
      $ }
      $ void get_nmodes(finufft_plan* plan, int64_t& ms, int64_t& mt, int64_t& mu) {
      $   ms = plan->ms ? plan->ms : 1;
      $   mt = plan->mt ? plan->mt : 1;
      $   mu = plan->mu ? plan->mu : 1;
      $   if(plan->dim<3) mu=1;
      $   if(plan->dim<2) mt=1;
      $ }
      $ int get_ntransf(finufft_plan* plan) {
      $   return plan->ntrans;
      $ }

      # int type = get_type(finufft_plan* plan);
      # int n_transf = get_ntransf(finufft_plan* plan);
      # int64_t nj = get_nj(finufft_plan* plan);
      % check data input length...
      if type==1 || type==2
        # get_nmodes(finufft_plan* plan, output int64_t& ms, output int64_t& mt, output int64_t& mu);
        ncoeffs = ms*mt*mu*n_transf;                  % total Fourier coeffs (out t1, or in t2)
      end
      if type==2, ninputs = ncoeffs; else, ninputs = n_transf*nj; end     % supposed input numel
      if numel(data_in)~=ninputs
        error('FINUFFT:badDataInSize','FINUFFT numel(data_in) must be n_trans times number of NU pts (type 1, 3) or Fourier modes (type 2)');
      end
      if type==1
        # int ier = finufft_exec(finufft_plan* plan, dcomplex[] data_in, output dcomplex[ncoeffs] result);
        % make output correct matlab shape; for d<3, squeeze removes unused dims...
        result = squeeze(reshape(result, [ms mt mu n_transf]));
      elseif type==2
        # int ier = finufft_exec(finufft_plan* plan, output dcomplex[nj, n_transf] result, dcomplex[] data_in);
      elseif type==3
        # int64_t nk = get_nk(finufft_plan* plan);
        # int ier = finufft_exec(finufft_plan* plan, dcomplex[] data_in, output dcomplex[nk, n_transf] result);
      else
        ier = 10;        % type must have been corrupted since plan stage - the horror
      end
      errhandler(ier);
    end

  end
end
